}
}
alpha = 1
beta = 3
for (k in length(pi_vector)){
# take unif distr if k == 1, else beta distr
if (k == 1){
sum = sum + pi_vector[k] * dunif(x)
}
else {
sum = sum + pi_vector[k] * dbeta(x,alpha,beta)
}
}
sum
sum = 0
for (k in length(pi_vector)){
# take unif distr if k == 1, else beta distr
if (k == 1){
sum = sum + pi_vector[k] * dunif(x)
}
else {
sum = sum + pi_vector[k] * dbeta(x,alpha,beta)
}
}
sum
clear(k)
clean(k)
k
sumn
sum
sum = 0
for (k in length(pi_vector)){
# take unif distr if k == 1, else beta distr
if (k == 1){
sum = sum + pi_vector[k] * dunif(x)
}
else {
sum = sum + pi_vector[k] * dbeta(x,alpha,beta)
}
}
sum
expected_resp <- function(x, pi_vector, j, alpha, beta){
sum = 0
w_i_j = 0
for (k in length(pi_vector)){
# take unif distr if k == 1, else beta distr
if (k == 1){
sum = sum + pi_vector[k] * dunif(x)
}
else {
sum = sum + pi_vector[k] * dbeta(x,alpha,beta)
}
}
# take unif distr if j == 1, else beta distr
if (j == 1) {
w_i_j = (pi_vector[j] * dunif(x)) / sum
}
else {
w_i_j = (pi_vector[j] * dbeta(x, alpha, beta)) / sum
}
#w_i_j
sum
}
expected_resp(x,pi_vector,1,alpha,beta)
k = 1
k==1
sum = 0
sum = sum + pi_vector[k] * dunif(x)
sum
k = 2
sum = sum + pi_vector[k] * dbeta(x,alpha,beta)
sum
sum = 0
for (k in length(pi_vector)){
# take unif distr if k == 1, else beta distr
if (k == 1){
sum = sum + pi_vector[k] * dunif(x)
}
else {
sum = sum + pi_vector[k] * dbeta(x,alpha,beta)
}
}
sum
k
expected_resp <- function(x, pi_vector, j, alpha, beta){
sum = 0
w_i_j = 0
for (k in length(pi_vector)){
# take unif distr if k == 1, else beta distr
if (k == 1){
sum = sum + pi_vector[k] * dunif(x)
}
else {
sum = sum + pi_vector[k] * dbeta(x,alpha,beta)
}
}
expec
expected_resp(x,pi_vector,1,alpha,beta)
expected_resp <- function(x, pi_vector, j, alpha, beta){
sum = 0
w_i_j = 0
for (k in length(pi_vector)){
# take unif distr if k == 1, else beta distr
#if (k == 1){
#  sum = sum + pi_vector[k] * dunif(x)
#}
#else {
sum = sum + pi_vector[k] * dbeta(x,alpha[k],beta[k])
#}
}
# take unif distr if j == 1, else beta distr
# if (j == 1) {
#   w_i_j = (pi_vector[j] * dunif(x)) / sum
# }
# else {
w_i_j = (pi_vector[j] * dbeta(x, alpha[k], beta[k])) / sum
#}
#w_i_j
sum
}
expected_resp <- function(x, pi_vector, j, alpha, beta){
sum = 0
w_i_j = 0
for (k in length(pi_vector)){
# take unif distr if k == 1, else beta distr
#if (k == 1){
#  sum = sum + pi_vector[k] * dunif(x)
#}
#else {
sum = sum + pi_vector[k] * dbeta(x,alpha[k],beta[k])
#}
}
# take unif distr if j == 1, else beta distr
# if (j == 1) {
#   w_i_j = (pi_vector[j] * dunif(x)) / sum
# }
# else {
w_i_j = (pi_vector[j] * dbeta(x, alpha[j], beta[j])) / sum
#}
#w_i_j
sum
}
expected_resp(x,pi_vector,1,c(1,1),c(1,3))
expected_resp(x,pi_vector,1,c(1,1),c(1,3))
test = 1
test
}
expected_resp <- function(x, pi_vector, j, alpha, beta){
sum = 0
w_i_j = 0
for (k in length(pi_vector)){
# take unif distr if k == 1, else beta distr
#if (k == 1){
#  sum = sum + pi_vector[k] * dunif(x)
#}
#else {
sum = sum + pi_vector[k] * dbeta(x,alpha[k],beta[k])
#}
}
# take unif distr if j == 1, else beta distr
# if (j == 1) {
#   w_i_j = (pi_vector[j] * dunif(x)) / sum
# }
# else {
w_i_j = (pi_vector[j] * dbeta(x, alpha[j], beta[j])) / sum
#}
#w_i_j
sum
}
expected_resp(x,pi_vector,1,c(1,1),c(1,3))
sum = 0
sum = sum + pi_vector[k] * dbeta(x,alpha[k],beta[k])
sum
k
k = 1
sum = 0
alpha = c(1,3)
beta = c(1,3)
alpha = c(1,1)
sum = sum + pi_vector[k] * dbeta(x,alpha[k],beta[k])
sum
sum(2,3)
expected_resp <- function(x, pi_vector, j, alpha, beta){
sum = 0
w_i_j = 0
for (k in length(pi_vector)){
# take unif distr if k == 1, else beta distr
#if (k == 1){
#  sum = sum + pi_vector[k] * dunif(x)
#}
#else {
sum <- sum + pi_vector[k] * dbeta(x,alpha[k],beta[k])
#}
}
# take unif distr if j == 1, else beta distr
# if (j == 1) {
#   w_i_j = (pi_vector[j] * dunif(x)) / sum
# }
# else {
w_i_j = (pi_vector[j] * dbeta(x, alpha[j], beta[j])) / sum
#}
#w_i_j
sum
}
sum
sum = 0
for (k in length(pi_vector)){
# take unif distr if k == 1, else beta distr
#if (k == 1){
#  sum = sum + pi_vector[k] * dunif(x)
#}
#else {
sum <- sum + pi_vector[k] * dbeta(x,alpha[k],beta[k])
#}
}
sum
sum = 0
for (k in length(pi_vector)) {
# take unif distr if k == 1, else beta distr
#if (k == 1){
#  sum = sum + pi_vector[k] * dunif(x)
#}
#else {
sum <- sum + (pi_vector[k] * dbeta(x,alpha[k],beta[k]))
#}
}
sum
for (k in length(pi_vector)) {
# take unif distr if k == 1, else beta distr
#if (k == 1){
#  sum = sum + pi_vector[k] * dunif(x)
#}
#else {
sum <- sum + (pi_vector[k] * dbeta(x,alpha[k],beta[k]))
sum
#}
}
sum
for (i in 1:3){
sum <- sum + 1
}
sum
for (k in length(pi_vector)) {
# take unif distr if k == 1, else beta distr
#if (k == 1){
#  sum = sum + pi_vector[k] * dunif(x)
#}
#else {
sum <- sum + ((pi_vector[k] * dbeta(x,alpha[k],beta[k])))
#}
}
sum
sum
sum = 0
length(pi_vector)
length(pi_vector)[1]
length(pi_vector)[[1]]
sum = 0
length_vect = length(pi_vector)
for (k in length_vect) {
# take unif distr if k == 1, else beta distr
#if (k == 1){
#  sum = sum + pi_vector[k] * dunif(x)
#}
#else {
sum <- sum + ((pi_vector[k] * dbeta(x,alpha[k],beta[k])))
#}
}
sum
k
k = 1
for (k in length_vect) {
# take unif distr if k == 1, else beta distr
#if (k == 1){
#  sum = sum + pi_vector[k] * dunif(x)
#}
#else {
sum <- sum + ((pi_vector[k] * dbeta(x,alpha[k],beta[k])))
#}
}
sum
load('allp.Rdata')
allp
allp[1]
allp[1,1]
size(allp)
allp[1]
allp
allp[1][1]
allp[1][1][1]
head(allp)
ls()
allp[1]
allp[2]
allp[3]
allp[4]
allp[5]
allp[4]
allp[4][1:2]
allp[4][1]
allp[4]
test1 = allp[4]
test1
test1[1]
test1[1:2]
test1[1,2]
test1[1:2]
test1[1][1]
test1
df <- data.frame(x = 1:5, y = 6:10)
save(df, file = "allp.RData")
savedFile = "allp.Rdata"
newRow = c(50,100)
load(savedFile, new.env())
df = rbind(df, newRow)
save(df, file = savedFile)
df
c(allp[1])
c(allp[1])[1]
typeof(allp)
typeof(allp[1])
typeof(allp[1][1])
class(allp)
atributes(allp)
attributes(allp)
names(allp)
allp[[1]]
typeof(allp[1])
typeof(allp[[1])
typeof(allp[[1])
typeof(allp[[1]])
typeof(allp[[1]])
allp[[1]]
allp[[1]][[1]]
allp[1][[1]]
allp[[1]][[1]]
typeof(allp[[1]])
allp[[1]]
c(allp[[1]])
hist(allp[[1]])
p[[1]]
hist(pvector1)
pvector1 = allp[[1]]
hist(pvector1)
length(allp)
c(4)
c(1,4)
seq(1,4)
string = 'hoi'
strin + 1
string + '1'
string + "1"
paste(string, "1")
paste(string,"1")
paste(string,"1", sep='')
begin_name = "pvector"
for (vector_number in seq(1,length(allp))){
name = paste(begin_name, vector_number, sep='')
assign(name, allp[[vector_number]])
hist(name)
}
begin_name = "pvector"
vector_number = 1
name = paste(begin_name, vector_number, sep='')
name
assign(name, allp[[vector_number]])
name
pvector1
name
pvector1
name
pvector1
for (vector_number in seq(1,length(allp))){
hist(allp[[1]])
}
for (vector_number in seq(1,length(allp))){
hist(allp[[vector_number]])
}
help(hist)
for (vector_number in seq(1,length(allp))){
hist(allp[[vector_number]], main="Hist of pvector" + vector_number)
}
for (vector_number in seq(1,length(allp))){
hist(allp[[vector_number]], main=paste("Hist of pvector", vector_number))
}
for (vector_number in seq(1,length(allp))){
hist(allp[[vector_number]], main=paste("Hist of pvector", vector_number),xlab = "p value")
}
help(normalmixEM)
load('allp.Rdata')
ls()
typeof(allp)
attributes(allp)
typeof(allp[1])
typeof(allp[[1]])
allp[[1]][[1]]
# histograms
pvector1 = allp[[1]]
hist(pvector1)
par(mfrow=c(2,2))
for (vector_number in seq(1,length(allp))){
hist(allp[[vector_number]], main=paste("Hist of pvector", vector_number),xlab = "p value")
}
plot(sort(pvector1))
# first test on likelihood
# install.packages("plot3D")
library(plot3D)
load('allp.Rdata')
mixture_density <- function(x, pi_0, pi_1, alpha, beta){
pi_0 * dunif(x) + pi_1 * dbeta(x,alpha,beta)
}
likelihood <- function(data,pi_0, pi_1, alpha, beta) {
sum = 0
for (i in 1:length(data)){
sum = sum + mixture_density(data[i],pi_0, pi_1, alpha, beta)
}
sum
}
expected_resp <- function(x, pi_vector, j, alpha, beta){
sum = 0
w_i_j = 0
length_vect = length(pi_vector)
for (k in 1:length_vect) {
sum <- sum + ((pi_vector[k] * dbeta(x,alpha[k],beta[k])))
}
w_i_j = (pi_vector[j] * dbeta(x, alpha[j], beta[j])) / sum
# return
w_i_j
}
averaged_resp_weights <- function(data, pi_vector, alpha, beta) {
#sum = 0
pi_new_vector = 0
for (j in 1:length(pi_vector)){
sum = 0
for (i in 1:length(data)){
sum = sum + expected_resp(data[i], pi_vector, j, alpha, beta)
}
# average is new value for pi_j^+
average = sum / length(data)
pi_new_vector[j] = average
}
pi_new_vector
}
#####
pi_vector = c(0.3,0.4,0.3)
alpha = c(1,1,5)
beta = c(1,3,1)
em_algo <- function(data,pi_vector,alpha,beta, number_of_iterations){
for (n in 1:number_of_iterations){
pi_vector = averaged_resp_weights(data, pi_vector, alpha, beta)
}
pi_vector
}
# plot for beta variable
## initiate values
pi_0 = 0.5
pi_1 = 1 - pi_0
alpha = 1
betas = seq(0,10,0.5)
plot(betas, likelihood(allp$p1,pi_0, pi_1, apha, betas))
# 3d plot for alpha beta variable
pi_0 = 0.5
pi_1 = 1 - pi_0
alphas = seq(0,10,0.5)
betas = seq(0,10,0.5)
M <- mesh(alphas,betas)
surf3D(M$x,M$y,likelihood(allp$p1,pi_0,pi_1,M$x,M$y), colkey=FALSE,bty="b2",xlab="alpha",ylab="beta",zlab="likelihood")
plot_distribution <- function(data, pi_vector, alpha, beta){
hist(data,freq=FALSE)
x <- seq(0,1,0.01)
y <- vector(mode="numeric", length=length(x))
sum = 0
for (i in 1:length(x)){
for (k in 1:length(pi_vector)){
y[i] <- y[i] +  pi_vector[k] * dbeta(x[i],alpha[k],beta[k])
}
}
lines(x,y)
}
data = allp$p1
alpha = c(1,1,5)
beta = c(1,3,1)
number_of_iterations = 25
# initial value
pi_vector = c(0.3,0.4,0.3)
# run EM algo
pi_vector <- em_algo(data,pi_vector,alpha,beta,number_of_iterations)
# plot result
plot_distribution(data, pi_vector, alpha, beta)
# variables
data = allp$p1
alpha = c(1,1)
beta = c(1,3)
number_of_iterations = 25
# initial value
pi_vector = c(0.3,0.4,0.3)
# run EM algo
pi_vector <- em_algo(data,pi_vector,alpha,beta,number_of_iterations)
# plot result
plot_distribution(data, pi_vector, alpha, beta)
# plot result
plot_distribution(data, pi_vector, alpha, beta)
data = allp$p1
alpha = c(1,1)
beta = c(1,3)
number_of_iterations = 25
# initial value
pi_vector = c(0.3,0.4)
# run EM algo
pi_vector <- em_algo(data,pi_vector,alpha,beta,number_of_iterations)
# plot result
plot_distribution(data, pi_vector, alpha, beta)
